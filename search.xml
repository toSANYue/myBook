<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于vue2的一点事儿</title>
    <url>/myBook/2022/07/29/hello-world/</url>
    <content><![CDATA[<h1 id="vue基础的原理实现"><a href="#vue基础的原理实现" class="headerlink" title="vue基础的原理实现"></a>vue基础的原理实现</h1><h2 id="一-指令"><a href="#一-指令" class="headerlink" title="一.指令"></a>一.指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">指令分为全局指令和局部指令,全局指令注册在main.js中,局部指令注册在各个组件中</span><br></pre></td></tr></table></figure>

<h3 id="1-全局指令"><a href="#1-全局指令" class="headerlink" title="1.全局指令"></a>1.全局指令</h3><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="(1).基本语法"></a>(1).基本语法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.directive(&#x27;directiveName&#x27;,&#123;bind()&#123;&#125;,inserted()&#123;&#125;,updated()&#123;&#125;,componentUpdated()&#123;&#125;,unbind()&#123;&#125; &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-实例展示"><a href="#2-实例展示" class="headerlink" title="(2).实例展示"></a>(2).实例展示</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;myFouce&#x27;</span>, &#123;</span><br><span class="line">/**</span><br><span class="line">    全局注册自定义指令五个钩子函数<span class="built_in">bind</span>(),inserted(),update(),componentUpdated(),unbind(),每个钩子函数接受四个参数:</span><br><span class="line">    el:指令绑定不在那个元素上,比如在div上,el就是div的dom对象</span><br><span class="line">    binding:&#123;&#125;,包含指令的部分信息,比如名字,value等,value是从自定义指令接受数据</span><br><span class="line">    vNode:指令现在的节点,一般绑定在谁身上就是谁</span><br><span class="line">    oldVnode:指令之前的节点</span><br><span class="line">*/</span><br><span class="line">  <span class="built_in">bind</span> (el, binding, vNode, oldVnode) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line">    console.log(el, binding, vNode, oldVnode)</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;,//执行一次,就是绑定元素于指令</span><br><span class="line">  inserted (el, binding, vNode, oldVnode) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;inserted&#x27;</span>)</span><br><span class="line">    console.log(el, binding, vNode, oldVnode)</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;,//作用于大部分的指令功能</span><br><span class="line">  update (el, binding, vNode, oldVnod) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;update&#x27;</span>)</span><br><span class="line">    console.log(el, binding, vNode, oldVnod)</span><br><span class="line">    // el.focus()</span><br><span class="line">  &#125;,//可能不会生效,虚拟节点可能没准备好</span><br><span class="line">  componentUpdated (el, binding, vNode, oldVnode) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;componentUpdated&#x27;</span>)</span><br><span class="line">    console.log(el, binding, vNode, oldVnode)</span><br><span class="line">    // el.focus()</span><br><span class="line">  &#125;,//在该钩子函数内,任何时候都能执行功能,因为虚拟节点准备好了</span><br><span class="line">  unbind (el, binding, vNode, oldVnode) &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;unbind&#x27;</span>)</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;//接触指令与绑定的标签元素</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="2-局部指令"><a href="#2-局部指令" class="headerlink" title="2.局部指令"></a>2.局部指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">局部指令和全局指令类似,只不过用法稍微不一样</span><br><span class="line">  directives: &#123;</span><br><span class="line">    myFouce: &#123;</span><br><span class="line">      <span class="function"><span class="title">inserted</span></span> () &#123;&#125;</span><br><span class="line">      //等等钩子函数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="二-修饰符"><a href="#二-修饰符" class="headerlink" title="二.修饰符"></a>二.修饰符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">修饰符分为三种:事件修饰符,按键修饰符,精准修饰符</span><br></pre></td></tr></table></figure>

<h3 id="1-事件修饰符"><a href="#1-事件修饰符" class="headerlink" title="1.事件修饰符"></a>1.事件修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">事件修饰符:  @click.stop = handleClick()阻止冒泡;@cick.passive = handlecikck()阻塞后面的事件,直到当前事件完成等等修饰符</span><br><span class="line">用于对v-on产生的事件作出类似于原生dom的修饰方法</span><br></pre></td></tr></table></figure>

<h3 id="2-按键修饰符"><a href="#2-按键修饰符" class="headerlink" title="2.按键修饰符"></a>2.按键修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">按键修饰符: .enter, .ctrl, .esc等等按下某个按键的时候才触发对应的事件,用于对键盘按键的控制</span><br></pre></td></tr></table></figure>

<h3 id="3-精准修饰符"><a href="#3-精准修饰符" class="headerlink" title="3.精准修饰符"></a>3.精准修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">精准修饰符: .exact,精确的控制,只有当按下那个修饰符的时候才能触发(普通情况下,.ctrl修饰时,就是同时按下alt和<span class="built_in">shift</span>也能触发)</span><br></pre></td></tr></table></figure>

<h2 id="三-插槽"><a href="#三-插槽" class="headerlink" title="三.插槽"></a>三.插槽</h2><ol>
<li><p><strong>在组件中,一般会在组件中留下些许个位置用<code> &lt;slot&gt;&lt;/slot&gt;</code>占位,这些未知表示留个用户自己插入元素数据,当我们在父组件中要是用到这些插槽的时候,根据插槽名字填入相应的内容就可以</strong></p>
</li>
<li><p><strong>插槽类型</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">匿名插槽 : 没有名称的插槽和具名插槽在这一点上相反</span><br><span class="line">具名插槽 : 有名字的插槽,在某些ui库中将某些组件的属性拿出来单独放在一个`&lt;slot&gt;&lt;slot/&gt;`标签里面</span><br><span class="line">		  子组件 &lt;slot  name= <span class="string">&quot;slotName&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">		  父组件,具体标签具体应用(都是放在子组件内的哈)比如:</span><br><span class="line">          &lt;template  v-slot:slotName&gt;&lt;div&gt;&#123;&#123;插值表达式,可以放函数&#125;&#125;&lt;/div&gt;&lt;/template&gt; 2.6.0之后</span><br><span class="line">          &lt;template slot=<span class="string">&quot;slotName&quot;</span>&gt;&lt;div&gt;&#123;&#123;插值表达式,可以放函数&#125;&#125;&lt;/div&gt;&lt;/template&gt;2.6.0之前</span><br><span class="line">          &lt;div slot=<span class="string">&quot;slotName&quot;</span>&gt;&#123;&#123;插值表达式,可以放函数&#125;&#125;&lt;/div&gt; 2.6.0之前</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用域插槽 : 父组件有时候想使用子组件的变量数据,通过动态绑定来实现</span><br><span class="line">		  子组件:&lt;slot :username = username&gt;&lt;/slot&gt; 假定子组件有一个username的变量</span><br><span class="line">          父组件:&lt;template v-slot:default=<span class="string">&quot;slotProps&quot;</span>&gt;&#123;&#123; slotProps.username.firstName &#125;&#125;&lt;/template&gt;</span><br><span class="line">    	  slotProps自己去的名字,类似于ref,可以再这个对象中拿到username</span><br><span class="line">    	  &lt;template slot=<span class="string">&quot;default&quot;</span> slot-scope=<span class="string">&quot;slotProps&quot;</span>&gt;&#123;&#123; slotProps.msg &#125;&#125;&lt;/template&gt; 2.6.0之前</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="四-动态组件"><a href="#四-动态组件" class="headerlink" title="四.动态组件"></a>四.动态组件</h2><h3 id="1-component"><a href="#1-component" class="headerlink" title="1.component"></a>1.component</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;component include=<span class="string">&#x27;正则/数组字/符串&#x27;</span> exclude=<span class="string">&#x27;正则/数组字/符串&#x27;</span> max=10 :is=<span class="string">&quot;组件名&quot;</span>&gt;&lt;/component&gt;动态组件可以根据不同的名字来切换把不同的组件</span><br><span class="line">条件缓存:</span><br><span class="line">	include:都是有条件的缓存组件,满足条件的缓存</span><br><span class="line">	exclude:不满足及条件之外的缓存</span><br><span class="line">缓存最大数量:</span><br><span class="line">	max:最大的缓存数量,如果超过了这个数量,就会在执行栈删除最先缓存的那个组件</span><br></pre></td></tr></table></figure>

<h3 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2.keep-alive"></a>2.keep-alive</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;/keep-alive&gt;这个内置的组件可以帮我们缓存组件的内容,避免切换回当前组件时,重复渲染浪费性能,通常和动态组件一起使用</span><br><span class="line">独有的两个生命周期函数:</span><br><span class="line">	<span class="function"><span class="title">activated</span></span>()&#123;&#125;</span><br><span class="line">    组件在激活时可执行该函数</span><br><span class="line">    过程:组件没被销毁之前</span><br><span class="line">    场景:在组件被销毁后在现组件,用<span class="function"><span class="title">activated</span></span>()&#123;&#125;和<span class="function"><span class="title">deactivated</span></span>()&#123;&#125;比用<span class="function"><span class="title">boforeDestroy</span></span>()&#123;&#125;和<span class="function"><span class="title">destroyed</span></span>()&#123;&#125;更加节省性能</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">deactivated</span></span>()&#123;&#125;</span><br><span class="line">    组件失活,还没被激活的时候的钩子函数,比如组件被&lt;keep-alive&gt;&lt;/keep-alive&gt;包裹时调用</span><br><span class="line"></span><br><span class="line">	总结:这两个钩子函数的调用早于<span class="function"><span class="title">beforeDestroy</span></span>()&#123;&#125;和<span class="function"><span class="title">destroyed</span></span>()&#123;&#125;,在组件复现的时候更加节约性能</span><br></pre></td></tr></table></figure>








]]></content>
  </entry>
  <entry>
    <title>vue-vuex</title>
    <url>/myBook/2022/07/30/vue-vuex/</url>
    <content><![CDATA[<h1 id="vuex状态管理器"><a href="#vuex状态管理器" class="headerlink" title="vuex状态管理器"></a>vuex状态管理器</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">state:&#123;&#125;类似于vue中的<span class="function"><span class="title">data</span></span>()&#123;&#125;,存放响应式数据的地方</span><br><span class="line">辅助函数mapState</span><br><span class="line">    使用方法1在选项中使用,state:&#123;a:12&#125;</span><br><span class="line">        import &#123; mapSate&#125; form <span class="string">&quot;vue&quot;</span></span><br><span class="line">        mapState([<span class="string">&#x27;a&#x27;</span>]),也可以传入一个对象,就看名称你想不想改变,可以用延展运算符展开就行</span><br><span class="line">    使用方法2在模板中使用</span><br><span class="line">        使用方法</span><br><span class="line">            <span class="variable">$store</span>.state.a</span><br></pre></td></tr></table></figure>

<h2 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getters:&#123;&#125;类似于vue中的计算属性computed:&#123;&#125;</span><br><span class="line">    使用方法</span><br><span class="line">        和computed写法上有点不同,这里直接写函数,不建议写对象的形式</span><br><span class="line">        每一个方法都可以接受两个参数,参数的具体含义自行打印查看</span><br><span class="line">辅助函数mapGetters</span><br><span class="line">    使用方法1在选项中使用</span><br><span class="line">        和mapState使用方法一样</span><br><span class="line">        使用方法2在模板中使用</span><br><span class="line">            <span class="variable">$store</span>.getter.doneTodos()</span><br></pre></td></tr></table></figure>

<h2 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutations:&#123;&#125;类似于vue中的method,只不过是同步的方法</span><br><span class="line">	使用方法</span><br><span class="line">		<span class="variable">$store</span>.commit(funName,payload)</span><br><span class="line">辅助函数mapMutstions()</span><br><span class="line">	使用方法1在选项中使用</span><br><span class="line">    和上面的其他辅助函数一样,只不过还是展开到methods中</span><br><span class="line"></span><br><span class="line">使用方法2在模板中使用</span><br><span class="line">    <span class="variable">$store</span>.commit(<span class="string">&#x27;mutations中的函数名&#x27;</span>, <span class="string">&#x27;mutations中函数的参数值&#x27;</span>)</span><br><span class="line">    <span class="variable">$store</span>.commit(&#123;<span class="built_in">type</span>:<span class="string">&#x27;mutations中的函数名&#x27;</span>,<span class="string">&#x27;随便一个名字&#x27;</span> : <span class="string">&quot;&#x27;mutations中函数的参数值&#x27;&quot;</span> &#125;)</span><br><span class="line">    就是说你可以直接传递形参,也可以把形参放在一个对象中传递过去</span><br></pre></td></tr></table></figure>

<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">actions:&#123;&#125;和mutions:&#123;&#125;一样,但是actions是定义异步的方法的地方</span><br><span class="line">    和mutations不一样的地方有:</span><br><span class="line">        方法中接收的第一个参数表达的意思不同,actions中的方法第一个参数是mutations,而mutations中的方法第一个参数是state</span><br><span class="line">        模板中使用不同,<span class="variable">$store</span>.dispatch(<span class="string">&#x27;actions中的方法名&#x27;</span>,<span class="string">&#x27;传递的值&#x27;</span>)</span><br><span class="line">        由于是异步的方法,vuex封装了promise,每一次调用<span class="variable">$store</span>.dispatch()返回的都是promise</span><br><span class="line">        辅助函数名称不一样actions中叫做mapActions()</span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vuex允许我们划分小模块</span><br><span class="line">使用方法</span><br><span class="line">	将每一个小模块单独放在一个对象中,开启命名空间namespace = <span class="literal">true</span></span><br><span class="line">	假设这个模块叫做user</span><br><span class="line">调用方法</span><br><span class="line">	state:<span class="variable">$store</span>.state.user.a</span><br><span class="line">	mutations:<span class="variable">$store</span>.commit(user/youFn , payload)</span><br><span class="line">	actions:<span class="variable">$store</span>.dispatch(user/youFn, payload)</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mutations:&#123;&#125;中方法接受两个参数,参数一的含义就是state,参数二的含义就是在组件中传递过来的值</span><br><span class="line">actions:&#123;&#125;的方法也接受两个参数,参数一表示mutations,参数二表示组件中传递雇来的值</span><br><span class="line">基本的一个使用思路或者使用过程:</span><br><span class="line">	vuex作为数据管理的地方,通过对应的几个内置api,来与组件之间形成连接,主要用于存放公共的代码,</span><br><span class="line">	比如登陆请求,支付请求等等,即所有用户的共有行为的代码存放地</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>vue2的补充</title>
    <url>/myBook/2022/07/30/vue2%E7%9A%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">全局混入 : mixin</span><br><span class="line">	语法:Vue.mixin(&#123;</span><br><span class="line">  		// 这里是vue中的data,create,等</span><br><span class="line">		&#125;)</span><br><span class="line">	</span><br><span class="line">局部混入 ： mixins</span><br><span class="line">	语法:  mixins: &#123;</span><br><span class="line">    		<span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">      			<span class="built_in">return</span> &#123;&#125;</span><br><span class="line">    		&#125;,</span><br><span class="line">    		<span class="function"><span class="title">created</span></span> () &#123;&#125;,</span><br><span class="line">    		<span class="function"><span class="title">mounted</span></span> () &#123;&#125;,</span><br><span class="line">    		methods: &#123;&#125;,</span><br><span class="line">    		computed: &#123;&#125;,</span><br><span class="line">    		watch: &#123;&#125;</span><br><span class="line">  		&#125;,</span><br><span class="line">混入的先后顺序:</span><br><span class="line">	混入时,如果组件和混入的文件具有相同的属性名(data中的变量),那么以组件中的为准,如果钩子函数冲突了,先执行混入文件的钩子函数,在执行组件的</span><br><span class="line">混入的优缺点:</span><br><span class="line">	缺点:混入具有变量名冲突的问题,可能会被滥用,不是自己写的,其他人维护起来不知道该怎么用</span><br><span class="line">	优点:对于一小段代码来讲,重用性很高,方便复用</span><br></pre></td></tr></table></figure>

<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">全局过滤 : filter</span><br><span class="line">	语法:Vue.filter(<span class="string">&#x27;filterName&#x27;</span>, &#123;</span><br><span class="line">		//对象里面是一个方法,该方法必须要有返回值</span><br><span class="line">	&#125;)</span><br><span class="line">局部过滤 : filters</span><br><span class="line">	语法:filters:&#123;//对象里面是一个方法,该方法必须要有返回值&#125;</span><br><span class="line">为什么要过滤器函数要有返回值?</span><br><span class="line">	答:在vue中过滤器多作用在插值表达式上,和管道符一起匹配,因为插值表达式只接受表达式,变量,不接受函数</span><br><span class="line">函数有无返回值的意义是否一样?</span><br><span class="line">	答:函数若是有了返回值,name其实这个函数也就变成了一个表达式或者一个特定的值;如果没有返回值的话,函数执行到最后还是函数</span><br><span class="line">过滤器依赖什么?</span><br><span class="line">	答:过滤器和计算属性一样依赖于响应式数据,从而得出某种结果,或者筛选某种结果</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>关于vueAPI的亿点点事</title>
    <url>/myBook/2022/07/29/vueAPI/</url>
    <content><![CDATA[<h1 id="vue-API"><a href="#vue-API" class="headerlink" title="vue-API"></a>vue-API</h1><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.Vue.extent(&#123;//code&#125;)</span><br><span class="line">    创建Vue的子类包含,说白了就好像一个组件,但是和Vue.component(<span class="string">&quot;&quot;</span>,&#123;&#125;)不一样的是,Vue.extned创建的实例没有名字,无名的组件</span><br><span class="line"></span><br><span class="line">2.Vue.component(<span class="string">&quot;&quot;</span>,&#123;&#125;)</span><br><span class="line">    用于全局注册组件,参数一表示组件的名字,在main.js中使用就好,一般也不用这个注册组件</span><br><span class="line">    局部注册:导入子组件后,用components:&#123;子组件名字&#125;</span><br><span class="line"></span><br><span class="line">3.Vue.nextTick(callback)</span><br><span class="line">    在dom更新完成后立即调用回调函数,支持promise,用于操作视图,在v2中若试图没有随着数据的变化而变化,就需要用到this.<span class="variable">$nextTick</span>(callback)</span><br><span class="line">    主要是操作DOM的方法</span><br><span class="line"></span><br><span class="line">4.Vue.<span class="built_in">set</span>(target,key,value)</span><br><span class="line">    感觉所有的<span class="built_in">set</span>方法接受大参数都大同小异目标对象,对象的key,对象的value,[代理器对象本身,注:这个跟vue中的<span class="built_in">set</span>毫不相关]</span><br><span class="line">    用法:用于操作视图和数据的双向改变,在v2中若试图没有随着数据的变化而变化,就需要用到this.<span class="variable">$set</span>(),解决v2添加复杂数据的时候视图不跟着改变的问题</span><br><span class="line"></span><br><span class="line">5.Vue.directive( <span class="string">&#x27;指令的名字&#x27;</span>,&#123;指令处理对象&#125; )</span><br><span class="line">    全局注册自定义指令五个钩子函数<span class="built_in">bind</span>(),inserted(),update(),componentUpdated(),unbind(),每个钩子函数接受四个参数:</span><br><span class="line"></span><br><span class="line">6.Vue.filter(<span class="string">&#x27;过滤器的名字&#x27;</span>,<span class="keyword">function</span>(value)&#123;&#125;)</span><br><span class="line">    定义一个过滤器,用来处理数据</span><br><span class="line"></span><br><span class="line">7.Vue.use(导入的插件的名字)</span><br><span class="line">    安装vue的插件,插件必须要有一个叫做install的方法,在全局中使用较多</span><br><span class="line"></span><br><span class="line">8.Vue.mixin(&#123;&#125;)</span><br><span class="line">    全局混入一个对象,对象一般是<span class="built_in">export</span> default&#123;code&#125;里面的代码比如<span class="function"><span class="title">data</span></span>()&#123;<span class="built_in">return</span>&#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line">9.Vue.version</span><br><span class="line">    得到vue当前的版本</span><br><span class="line"></span><br><span class="line">10.Vue.compile(template)</span><br><span class="line">    用来解析模板的,主要解析字符串,通常和渲染函数一起使用render</span><br><span class="line"></span><br><span class="line">11.Vue.delete(target,propertyName/index)</span><br><span class="line">    解决删除的时候视图不响应变化的问题(避免使用)</span><br><span class="line"></span><br><span class="line">12.Vue.observable( object )</span><br><span class="line">    用来处理响应式数据的变化,返回这个对象的浅拷贝,操作这个浅拷贝</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-选项-x2F-数据"><a href="#1-选项-x2F-数据" class="headerlink" title="1.选项&#x2F;数据"></a>1.选项&#x2F;数据</h3><h4 id="1-data"><a href="#1-data" class="headerlink" title="(1).data(){}"></a>(1).data(){}</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">存放变量的地方,在组件中必须是函数,html中是可以是对象,因为要考虑到组件复用,利用闭包模拟私有变量,避免变量污染</span><br></pre></td></tr></table></figure>

<h4 id="2-props-在父子传参中对拿到的数据进行对应的处理和接受"><a href="#2-props-在父子传参中对拿到的数据进行对应的处理和接受" class="headerlink" title="(2).props{} : 在父子传参中对拿到的数据进行对应的处理和接受"></a>(2).props{} : 在父子传参中对拿到的数据进行对应的处理和接受</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">	a:&#123;</span><br><span class="line">		<span class="built_in">type</span>:Number,</span><br><span class="line">		required:<span class="literal">true</span>,</span><br><span class="line">		default:10,</span><br><span class="line">		<span class="function"><span class="title">validator</span></span>()&#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-propsData-在new实例中使用-组件中没有这个数据对象"><a href="#3-propsData-在new实例中使用-组件中没有这个数据对象" class="headerlink" title="(3).propsData()在new实例中使用,组件中没有这个数据对象"></a>(3).propsData()在new实例中使用,组件中没有这个数据对象</h4><h4 id="4-computed"><a href="#4-computed" class="headerlink" title="(4).computed"></a>(4).computed</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">计算属性,不是响应式的数据,只有当依赖的data中的变量改变的时候才会改变,并且具有缓存作用</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      gridColumn: 2,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;userToken&#x27;</span>]),</span><br><span class="line">    a1: &#123;</span><br><span class="line">      get: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="built_in">return</span> this.a1</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="built_in">set</span> (value) &#123;</span><br><span class="line">        value += this.gridColumn</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">运行机制是:只有当<span class="function"><span class="title">get</span></span>()&#123;&#125;得到结果后,之后才会调用<span class="built_in">set</span>(value)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-methods-x2F-x2F-处理函数-其中的this自动绑定vue实例"><a href="#5-methods-x2F-x2F-处理函数-其中的this自动绑定vue实例" class="headerlink" title="(5). methods:{&#x2F;&#x2F;处理函数}其中的this自动绑定vue实例"></a>(5). methods:{&#x2F;&#x2F;处理函数}其中的this自动绑定vue实例</h4><h4 id="6-watch-和计算属性不同的是watch是响应式的"><a href="#6-watch-和计算属性不同的是watch是响应式的" class="headerlink" title="(6).watch : 和计算属性不同的是watch是响应式的"></a>(6).watch : 和计算属性不同的是watch是响应式的</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法大致分为三种</span><br><span class="line">1.  a (value, oldValue) &#123;&#125;,</span><br><span class="line">2.  a1: <span class="string">&#x27;medthodName&#x27;</span>,</span><br><span class="line">3.  a2: &#123;</span><br><span class="line">      deep: <span class="literal">true</span>,</span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">      handler (value, oldValue) &#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-选项-x2F-DOM-只在实例中有-组件中没有"><a href="#2-选项-x2F-DOM-只在实例中有-组件中没有" class="headerlink" title="2.选项&#x2F;DOM : 只在实例中有,组件中没有"></a>2.选项&#x2F;DOM : 只在实例中有,组件中没有</h2><h2 id="3-选项-x2F-生命周期钩子函数"><a href="#3-选项-x2F-生命周期钩子函数" class="headerlink" title="3.选项&#x2F;生命周期钩子函数"></a>3.选项&#x2F;生命周期钩子函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组件具有生命周期,当不需要的时候就销毁,需要的时候再产生</span><br><span class="line">过程:实例创建------实例销毁</span><br></pre></td></tr></table></figure>

<h3 id="1-实例创建"><a href="#1-实例创建" class="headerlink" title="(1).实例创建"></a>(1).实例创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeCreate</span></span>()&#123;&#125;</span><br><span class="line">    在实例创建的时候调用,注意此时data等选项尚未初始化成功,</span><br><span class="line">        过程:实例化开始 ----&gt;  实例化结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">created</span></span>()&#123;&#125;</span><br><span class="line">    在实例化完成以后执行,此时data等选项初始化完成</span><br><span class="line">        过程:渲染页面完成的时候</span><br><span class="line">            页面刷新的时候调用,每一次刷新重新相当于重新渲染页面</span><br><span class="line">            一般在这里发请求</span><br></pre></td></tr></table></figure>

<h3 id="2-DOM创建"><a href="#2-DOM创建" class="headerlink" title="(2).DOM创建"></a>(2).DOM创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeMount</span></span>()&#123;&#125;</span><br><span class="line">    在挂载dom之前调用,dom编译好了,但是在这之前还没挂载在实例上</span><br><span class="line">        过程:此时dom开始挂载在实例上 ---&gt;  挂载结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounted</span></span>()&#123;&#125;</span><br><span class="line">    在这里主要是操作dom的改变</span><br><span class="line">        过程:dom怪哉在实例上结束</span><br><span class="line">            在这里是最早可以再vue中操作dom节点的位置</span><br></pre></td></tr></table></figure>

<h3 id="3-DOM修改"><a href="#3-DOM修改" class="headerlink" title="(3).DOM修改"></a>(3).DOM修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeUpdate</span></span>()&#123;&#125;</span><br><span class="line">    在dom被改变之前调用,此时data中的数据被改变了,但是视图还没没有来得及改变</span><br><span class="line">        过程:dom被改变了 ---&gt; 视图没有改变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">updated</span></span>()&#123;&#125;</span><br><span class="line">    在dom改变后视图也跟着改变了,虚拟dom重新渲染完成后调用</span><br><span class="line">        过程:dom改变后,虚拟dom重新渲染 ---&gt;  视图完成更新</span><br><span class="line">            在这里也可以操作dom,但是没必要,如果要等到所有的dom更新完成可以还使用this.<span class="variable">$nextTick</span>()</span><br></pre></td></tr></table></figure>

<h3 id="4-实例销毁"><a href="#4-实例销毁" class="headerlink" title="(4).实例销毁"></a>(4).实例销毁</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeDestroy</span></span>()&#123;&#125;</span><br><span class="line">    可在实例销毁之前调用,此时数据这些其实还没有销毁</span><br><span class="line">        过程:实例末期 ---&gt;  实例拜拜</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">destroyed</span></span>()&#123;&#125;</span><br><span class="line">    实例完全被销毁,啥都不可以用了</span><br><span class="line">        过程:实例拜拜了之后</span><br></pre></td></tr></table></figure>



<h3 id="5-特殊的生命周期"><a href="#5-特殊的生命周期" class="headerlink" title="(5).特殊的生命周期"></a>(5).特殊的生命周期</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">组件激活失活的钩子函数</span><br><span class="line">    <span class="function"><span class="title">activated</span></span>()&#123;&#125;</span><br><span class="line">        组件在激活时可执行该函数</span><br><span class="line">            过程:组件没被销毁之前</span><br><span class="line">                场景:在组件被销毁后在现组件,用<span class="function"><span class="title">activated</span></span>()&#123;&#125;和<span class="function"><span class="title">deactivated</span></span>()&#123;&#125;比用<span class="function"><span class="title">boforeDestroy</span></span>()&#123;&#125;和<span class="function"><span class="title">destroyed</span></span>()&#123;&#125;更加节省性能</span><br><span class="line">    <span class="function"><span class="title">deactivated</span></span>()&#123;&#125;</span><br><span class="line">        组件失活,还没被激活的时候的钩子函数,比如组件被&lt;keep-alive&gt;&lt;/keep-alive&gt;包裹时调用</span><br><span class="line"></span><br><span class="line">    总结:这两个钩子函数的调用比<span class="function"><span class="title">beforeDestroy</span></span>()&#123;&#125;和<span class="function"><span class="title">destroyed</span></span>()&#123;&#125;早</span><br><span class="line"></span><br><span class="line">错误捕捉的钩子函数</span><br><span class="line">    <span class="function"><span class="title">errorCaptured</span></span>()&#123;&#125;</span><br><span class="line">        捕捉后代组件出现的错误:可以阻止错误被不断的传递</span><br><span class="line">            过程:后代组件在没有被销毁之前,也就是<span class="function"><span class="title">destroyed</span></span>()&#123;&#125;被调用之前</span><br><span class="line">            规则,全局配置如果有错误捕捉的话,优先被全局捕捉</span><br></pre></td></tr></table></figure>



<h2 id="4-vue实例的属性"><a href="#4-vue实例的属性" class="headerlink" title="4.vue实例的属性"></a>4.vue实例的属性</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$data</span>:访问data中的数据</span><br><span class="line"><span class="variable">$el</span>:查看根元素</span><br><span class="line"><span class="variable">$props</span>:代理props访问接收到的变量,但是没必要直接this.变量访问</span><br><span class="line"><span class="variable">$parent</span>:后代访问祖先的元素,适用于父子通信</span><br><span class="line"><span class="variable">$children</span>:祖先访问子代元素</span><br><span class="line"><span class="variable">$options</span>:可以快捷的访问到data和props中的变量,便于重置</span><br><span class="line"><span class="variable">$root</span>:类似于parent</span><br><span class="line"><span class="variable">$slots</span>:v-slot:foo可以被this.<span class="variable">$slots</span>.foo取到,对应具名插槽</span><br><span class="line"><span class="variable">$scopedSlots</span>:可以再该对象中取到所有的<span class="variable">$slots</span>函数,对应作用于插槽</span><br><span class="line"><span class="variable">$refs</span>:ref一起使用,可以通过该属性访问到取有ref别名的子组件的所有可用的属性方法</span><br><span class="line"><span class="variable">$isServer</span>:看看vue是不是在服务端渲染</span><br><span class="line"><span class="variable">$attrs</span>:用于爷孙隔代通信:</span><br><span class="line">    爷爷组件中动态绑定到父亲组件,父亲组件不用props接受,而是在孙子组件上用v-bind = <span class="string">&quot;<span class="variable">$attrs</span>&quot;</span>接收到,然后再在孙子组件上用props接收到,</span><br><span class="line">    相当于把父亲组件当成中转站,这样就避免了父亲组件在用props接收,在绑定到孙子上重复劳作(父组件数据到子组件的偷懒写法)</span><br><span class="line"><span class="variable">$listeners</span>:用于爷孙组件隔代事件传递和上面的attrs用法一样(父组件事件到子组件的偷懒写法)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-实例的其他选项"><a href="#5-实例的其他选项" class="headerlink" title="5.实例的其他选项"></a>5.实例的其他选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name:<span class="string">&quot;&quot;</span>,给组件起个名字</span><br><span class="line"></span><br><span class="line">functional:<span class="literal">true</span>/false,一般和上面的<span class="function"><span class="title">render</span></span>()&#123;&#125;函数配套使用,此时就没有data,没有template</span><br><span class="line">    用来完成一些节点的改变,但是也不至于影响到全部的组件,这样代价更小</span><br><span class="line">    如果template上写了functional属性也可以不渲染template</span><br><span class="line">model:&#123;prop:<span class="string">&quot;value&quot;</span>,event:<span class="string">&quot;input&quot;</span>&#125;一般在一个组件中v-model其实就是v-bind和v-on的语法糖</span><br><span class="line">	modle选项的本质就是将v-modle拆分成value和input事件</span><br><span class="line">=============================================================</span><br><span class="line">delimiters:[<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>]:改变文本的得形式,可以插入分隔符</span><br><span class="line">====================================</span><br><span class="line">comments:<span class="literal">true</span>/false 可以保留编译注释</span><br><span class="line">inheritAttrs:<span class="literal">true</span>/false  祖先传递过来的数据是不是要绑定到dom元素的属性上,最好是<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="6-选项-x2F-资源"><a href="#6-选项-x2F-资源" class="headerlink" title="6.选项&#x2F;资源"></a>6.选项&#x2F;资源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filters:和全局的filter类似就是定义过滤器的,只是定义在局部组件</span><br><span class="line">directives:定义局部指令的</span><br><span class="line">components:注册局部组件的</span><br></pre></td></tr></table></figure>

<h2 id="7-内置指令"><a href="#7-内置指令" class="headerlink" title="7.内置指令"></a>7.内置指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">不常用的内置指令 都不接受任何表达式</span><br><span class="line">    v-pre  :跳过编译插值表达式的内容</span><br><span class="line">    v-once:只渲染一次,如果组件销毁后就不渲染对应的节点的数据,直接以静态内容显示</span><br><span class="line">    v-cloak:隐藏还没有编译的插值表达式,知道实例准备完毕在编译</span><br><span class="line">常用指令</span><br><span class="line">	v-for=<span class="string">&quot;(item,index) in arr&quot;</span> :key = <span class="string">&quot;index&quot;</span></span><br><span class="line">	v-if = <span class="string">&#x27;条件表达式&#x27;</span></span><br><span class="line">	v-on = <span class="string">&#x27;事件名&#x27;</span></span><br><span class="line">	v-bind = <span class="string">&#x27;变量名&#x27;</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="8-内置组件"><a href="#8-内置组件" class="headerlink" title="8.内置组件"></a>8.内置组件</h2><h3 id="1-component"><a href="#1-component" class="headerlink" title="1.component"></a>1.component</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;component include=<span class="string">&#x27;正则/数组字/符串&#x27;</span> exclude=<span class="string">&#x27;正则/数组字/符串&#x27;</span> max=10 :is=<span class="string">&quot;组件名&quot;</span>&gt;&lt;/component&gt;动态组件可以根据不同的名字来切换把不同的组件</span><br></pre></td></tr></table></figure>

<h3 id="2-keep-alive"><a href="#2-keep-alive" class="headerlink" title="2.keep-alive"></a>2.keep-alive</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;/keep-alive&gt;这个内置的组件可以帮我们缓存组件的内容,避免切换回当前组件时,重复渲染浪费性能,通常和动态组件一起使用</span><br></pre></td></tr></table></figure>

<h3 id="3-slot"><a href="#3-slot" class="headerlink" title="3.slot"></a>3.slot</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;slot name=<span class="string">&quot;slotName&quot;</span> :son = <span class="string">&quot;son&quot;</span>&gt;&lt;/slot&gt; 留下相应的空白,让使用该组件的人自己填入内容,通常和父组件的</span><br><span class="line">    作用域插槽 &lt;template slot-scope=<span class="string">&quot;scope&quot;</span> &amp; v-slot = <span class="string">&quot;son&quot;</span>&gt; &lt;span&gt;&#123;&#123; scope.son &amp; son &#125;&#125;&lt;/span&gt;&lt;/template&gt;</span><br><span class="line">    具名插槽 &lt;template slot=<span class="string">&quot;slotName&quot;</span> &amp; v-slot:slotName&gt; &lt;span&gt;&lt;/span&gt; &lt;/template&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
